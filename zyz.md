# 项目文档

## public文件夹：一般放置一些静态资源（图片），放在public文件夹中地静态资源，webpack在打包时会原封不动的打包到dist文件夹中

assets文件夹：一般也是放静态资源（一般放置多个组件共用的静态资源），需要注意，放置在assets文件夹里面的静态资源，在webpack打包时会把他当做一个模块，打包到js文件里面

components文件夹：一般放置非路由组件（全局组件）

APP.vue唯一的根组件
main.js：程序的入口，也是整个程序中最先执行的文件

babel.config.js: 配置文件（babel相关）

package.json: 认为是项目的身份证（记录项目叫做什么，项目中有哪些依赖，项目怎么运行）

package-lock.json: 缓存性文件

## 路由组件

Home首页路由组件，Search路由组件，login路由组件，注册路由组件
非路由组件：Header,Footer(在登录页和注册页没有)

配置路由的时候，可以给路由添加路由元信息meta，路由需要配置对象，他的key不能乱写
路由跳转的方式：声明式导航：router-link（务必要有to属性），可以实现路由跳转
               编程式导航：利用的是组件实例的$router.push|replace方法。（可以书写一些自己的业务）
路由传参： params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
          query参数：不属于路径当中的一部分，类似于ajax中的queryString，不需要占位

### 编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的警告错误

    声明式导航没有这类问题，因为vue-router底层已经处理好了

### 为什么编程式导航进行路由跳转的时候会有这种警告错误呢？

    最新的vue-router引入了promise

### 怎么解决这种警告

    通过给push方法传递相应的成功、失败的回调函数，可以捕获到当前错误。但是这种写法治标不治本，将来在别的组件当中push|replace,编程式导航还是有类似错误

this：当前组件实例
this.$router属性：当前的这个属性，属性值是VueRouter类的一个实例，当在入口文件注册路由时，给组件实例添加 $router | $route属性

## Home模块组件拆分

先把静态页面完成
拆分出静态组件
获取服务器的数据进行展示
动态业务

### 三级联动组件

由于三级联动在Home，Search，Detail都有，所以注册为全局组件
好处：只需要注册一次，就可以在项目的任何地方使用

## postman测试接口

如果服务器返回的数据code字段200，代表服务器返回数据成功
整个项目，接口前缀都有/api字样

## axios二次封装

XMLHTTPRequest,fetch,JQ,axios
为什么要进行二次封装axios?
请求拦截器、响应拦截器：请求拦截器可以在发请求之前处理一些业务；响应拦截器，当服务器数据返回以后，可以处理一些业务
在项目中经常出现一个api文件夹，就是用来存放有关axios请求的文件夹

## 接口的统一管理

项目很小：完全可以在组件的生命周期函数里面发请求
项目大

### 跨域问题

什么是跨域：协议，域名，端口号不同的请求，称之为跨域
'http://localhost:8080/#/home'---前端项目的本地服务器
'http://gmall-h5-api.atguigu.cn'---后台服务器

### bprogress进度条的使用

start:进度条开始
done进度条结束

### vuex实现模块式开发

如果项目过大，组件过多，接口很多，数据也很多，可以让vuex实现模块式开发
 modules: {
    home,
    search,
  }

### 通过JS控制三级联动中二三级商品分类的显示与隐藏

最开始的时候是通过css样式的display: block|none显示与隐藏

### 演示卡顿现象

正常：事件触发非常频繁，而每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）
节流：在规定时间里不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发
防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次

### 三级联动组件的路由跳转与参数传递

三级联动用户可以点击的：一级分类，二级分类，三级分类，当你点击的时候会从Home模块跳转到Search模块，一级会把用户选中的产品（产品的名字，产品的ID）在路由跳转时进行传递

三级联动：如果使用声明式导航router-link，可以实现路由跳转与传递参数，但是出现了卡顿现象
router-link：是一个组件，当服务器的数据返回后，会循环出很多的router-link（创建组件实例的）
创建组件实例的时候，一瞬间创建太多个是非常耗内存的，因此会出现卡顿

商品分类三级列表还可以进行优化：在APP根组件中派发action，这样可以只请求一次，避免多次请求浪费性能

### 合并params和query参数

### 开发Home首页当中的ListContainer组件与Floor组件

这里需要注意一件事，服务器返回的数据只有商品分类的操蛋分类数据，对于Listcontainer组件与Floor组件数据服务器没有提供
mock数据（模拟）：如果你想mock数据，需要用到一个插件mockjs
前端mock的数据不会和服务器进行任何通信

使用步骤：
1.在项目中src文件夹中创建mock文件夹
2.第二步准备json数据（mock文件夹中创建相应的json文件）
3.把mock数据需要的图片放置到public文件夹中（public文件夹在打包时，会把相应的资源原封不动的保存到dist文件夹中）
4.在mock文件夹下创建mockServe.js通过mockjs插件实现模拟数据
5.mockServe.js文件在入口文件中引入（至少需要执行一次，才能模拟数据）

### ListContainer组件开发重点

安装Swiper插件
解决轮播图问题：watch(数据监听) + nextTick
$nextTick：在下次DOM更新 循环结束之后 执行延迟回调。在修改数据之后，立即使用这个方法，获取更新后的DOM
$nextTick：可以保证页面中的结构一定是有的，经常和很多插件一起使用（都需要DOM已经存在了）

开发floor组件：getFloor这个action在哪里触发，是需要在Home路由组件当中发的，不能再Floor组件内部法action，因为需要v-for遍历遍历Floor组件
v-for也可以在自定义标签（组件标签）中使用

组件通信的方式有哪些
props：用于父子组件通信
自定义事件：$on $emit 可以实现子给父通信
全局事件总线：$bus 全能
pubsub-js：vue当中几乎不用 全能
插槽
vuex

### 把首页当中的轮播图拆分为一个公用的全局组件

切记：以后在开发时，如果看到某一个组件在很多地方都使用，就把他封装为全局组件
注册一次可以在任意地方使用，公用的组件|放到components文件夹里

### search模块开发

1.先静态页面+静态组件拆分出来
2.发请求（api）
3.vuex（三连环）
4.组件获取仓库数据，动态展示数据

vuex中的getters是为了简化数据而生

面包屑相关处理
1)动态开发面包屑中的分类名
编程式路由跳转（自己跳自己）
2)动态开发面包屑中的关键字
当面包屑中的关键字清除以后，需要让兄弟组件Header组件中的关键字清除(利用全局事件总线)
涉及到组件通信

### search摸块商品排序

1：综合 2：价格 asc：升序 desc：降序
2: 谁应该有active类名（通过order属性值中是包含1综合还是2价格）
3: 谁应该有箭头（谁有active类名就有箭头）
4: 箭头用什么制作(阿里图标库)

## 分页器组件开发

为什么很多电商平台都用到分页器：为了**减缓加载压力**

分页器展示，需要那些数据（条件）？
    需要知道当前是第几页：pageNo字段代表当前是第几页
    每一页需要展示多少条数据：pageSize字段代表
    整个分页器一共有多少条数据：total字段代表（暗含共有多少页）
    分页器连续页面个数：5|7（奇数，因为中间连续页码要对称）,由continues字段代表

自定义分页器：在开发的时候先自己传递假的数据进行调试，直到调试成功再用服务器数据

对于分页器而言，很重要的一个地方即为：算出**中间连续页码的起始数字和结束数字**。
例如：当前页是第8页(当前页永远处于中间位置)  …… 6 7 8 9 10 ……
但是要注意，分页器没有0和1，当然更没有负数
假如当前是第一页，应该是 1 2 3 4 5

### 分页器动态展示

将分页器的结构分为上中下三层
v-for可以遍历：数组，数字，字符串，对象(遍历数字时从1开始)

## 开发每一个产品的详情模块

1.静态组件(当点击商品的图片时，跳转到详情页面，在路由跳转时需要带上产品的id给详情页)
2.发请求
3.vuex
4.动态展示组件

### 加入购物车

浏览器存储功能：HTML5中新增的，本地存储和会话存储
本地存储-----持久化的，但只能存储5M左右
会话存储-----并非持久，会话结束就消失
本地存储和会话存储都不允许存储对象

### 购物车操作

**向服务器发请求获取购物车数据时，发现获取不到数据，这是因为服务器不知道你是谁，不知道要将谁的数据发送给你**
使用uuid作为游客的临时身份。
解决服务器获取不到购物车数据的方法: 加一个请求标头userTempId,其值为uuid（这样服务器才知道你是谁，才能将你的数据发给你）

修改购物车产品数量时，要用到函数的节流

删除选中的产品：注意，没有一次删除很多产品的接口。此处采用一种新思想，即派发一个action调用另一个action，将删除操作执行多次即可删除全部商品

全选操作：思想类比于删除选中的产品

## 登录与注册（必会技能）

登录业务： 注册----通过数据库存储用户信息（名字，密码）
          登录----登陆成功的时候，后台为了区分你这个用户是谁，服务器会下发一个token（令牌：唯一标识符）
一般登录成功后服务器会下发token，前台持久化存储token(带着token找服务器要用户信息进行展示)

token令牌理解：
    注意：vuex仓库存储数据-----不是持久化

登录过后首页用户信息的展示：当用户注册完成，登录时向服务器发请求  登录成功获取到token，存储于仓库当中（非持久化的），路由跳转到Home首页
                         因此在首页当中（mounted）派发action获取用户信息，以及动态在Header组件中展示内容
                         但是一刷新，仓库中的token没有了（vuex非持久化存储）

持久化存储token：本地存储localStorage

退出登录后要清除token和userInfo

**导航守卫**
导航：表示路由正在发生变化。进行路由跳转
守卫：当做“紫禁城护卫”

*全局守卫*: 项目当中只要发生路由变化，守卫就能监听到

比如：用户已经登录了，就不应该再回到login页面

未登录不能访问：交易相关（trade），支付相关（pay，paysuccess），用户中心（center）
**如果在未登录状态下，点击了我的订单（/center/myorder），此时会跳转到登录页面让你登录，但是按照正常的逻辑，登陆完之后应该去往之前点击的我的订单页面，所以在全局导航守卫中，将to.path作为query参数添加到地址栏中，然后在login组件中，将点击登录后跳转的页面改为去往query参数中的页面，如果没有就跳往home页面**

空对象在进行if判断时为真。“假值”总共只有6个：false，undefined，null，0，""（空字符串），NaN。除此之外的所有值，都是“真值”，即在逻辑判断中可以当true来使用
**利用导航守卫限制路由跳转时，判断条件较多，为重点内容**

*路由独享守卫*
只有从购物车界面才能跳转到交易页面（创建订单）
只有从交易页面（trade）才能跳转到支付页面
只有从支付页面才能跳转到支付成功页面

当登录之后，会获取到用户信息存储在vuex仓库当中，如果只是切换路由不进行刷新则vuex仓库中的数据并不会消失，但如果刷新，则vuex仓库当中的数据会消失，此时就需要重新派发action获取用户数据

### 交易页面完成

获取交易页面用户信息：用户登录了才可以获取用户地址信息，不登录没办法获取到（统一账号： 13700000000 111111）
点击提交订单的按钮时，还需要向服务器发起一次请求（把支付相关的一些信息发给服务器）

**从今天开始不再使用vuex**
*如果我们在组件中发请求，则需要一个一个的从api里面引用请求函数，这样非常不方便。因此我们在main.js中统一引入api中的全部请求函数，再将API绑定到Vue原型身上，这样在任何地方都可以通过this.$API来使用请求函数*
不能在生命周期函数前面加async

element-ui按需引入，配置文件发生变化，项目需要重启

弹出支付框以后，需要设置一个定时器，每隔一秒就向服务器发一次请求获取用户的支付状态（因为支付行为由用户决定，用户可能很久都不支付，所以要一直监听支付状态），当支付成功后（code=200）点击按钮即可跳转到支付成功页面

### 在center页面中拆分*二级路由*

html中表格里面可以用colspan属性和rowspan属性合并单元格
**center页面中我的订单部分，注意后面的结构要合并单元格，有多少条数据就会生成几行，就需要合并多少个单元格。但是，有多少条数据，就会v-for生成几行，除了第一个商品格，后面的收件人等数据因为合并了单元格，所以只需要显示一个，所以会产生多余扰乱页面结构。此时我们的对策是v-if让他只在index=0时显示一次，后面就不再显示**

### 图片懒加载：<https://www.npmjs.com/package/vue-lazyload>

图片和json文件都是默认对外暴露的，可以直接引用

### vee-validate 基本使用

plugins文件夹下的validate.js文件
其中zh_CN是设置为中文（因为该插件默认的提示信息为英文），attributes里面的内容是为了给这些字段分别设置一个中文名称，自定义校验规则是为了勾选协议
const success = await this.$validator.validateAll(); 如果所有的表单验证都成功了，就返回true，否则返回false

### 打包上线

项目打包后，代码都是经过压缩加密的。如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错
有了map就可以像未加密的代码一样，准确的输出是哪一行哪一列有错
所以该文件如果项目不需要是可以去除掉的(因为上线之后报错也无法修改，没有意义)
vue.config.js 配置
productionSourceMap:false

*购买云服务器*：
阿里云，腾讯云等
设置安全组，让服务器的一些端口号打开
利用xshell工具登录服务器
linux常用指令：cd跳转目录 ls查看 mkdir创建目录 pwd查看绝对路径

*nginx*
为什么访问服务器ip地址就可以访问到我们的项目（需要配置服务器）
项目的数据来源于<http://39.98.123.211>而不是购买的服务器，所以需要nginx进行反向代理
配置：
1.xshell进入根目录/etc
2.进入etc目录，这个目录下有一个nginx目录，进入到这个目录
3.安装nginx： yum install nginx
4.安装完nginx服务器之后，在nginx目录下，多了一个nginx.conf文件，在这个文件中进行配置
5.vim nginx.conf进行编辑，主要添加如下两项 root和api
6.nginx服务器跑起来
service nginx start
